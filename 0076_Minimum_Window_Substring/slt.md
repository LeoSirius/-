### 思路1 滑动窗口

- 时间复杂度 $O(n)$
    虽然 for 中有 while，但是 l 在外层的 for 范围内，也只会移动 n 次。所以是 n
- 空间复杂度 $O(1)$

滑动窗口算法的思路是这样：

1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。

2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。

3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

检测滑动窗口是否满足条件的方法：

array<int, 128> count{0};       // 记录 t 中已经出现的各个字符，但窗口中还差的个数
array<bool, 128> flags{false};  // 记录字符是否在 t 中